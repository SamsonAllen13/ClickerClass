using ClickerClass.Buffs;
using ClickerClass.Core.Netcode.Packets;
using ClickerClass.Items;
using ClickerClass.Items.Accessories;
using ClickerClass.Items.Consumables;
using ClickerClass.Items.Misc;
using ClickerClass.Projectiles;
using ClickerClass.Utilities;
using Microsoft.Xna.Framework;
using System;
using System.Collections.Generic;
using System.Linq;
using Terraria;
using Terraria.Audio;
using Terraria.DataStructures;
using Terraria.GameContent.Drawing;
using Terraria.GameInput;
using Terraria.ID;
using Terraria.ModLoader;
using Terraria.ModLoader.IO;

namespace ClickerClass
{
	public partial class ClickerPlayer : ModPlayer
	{
		//Key presses
		public double pressedAutoClick;
		public int clickerClassTime = 0;

		//-Clicker-
		//Misc
		public Color clickerRadiusColor = Color.White;
		/// <summary>
		/// Cached clickerRadiusColor for draw
		/// </summary>
		public Color clickerRadiusColorDraw = Color.Transparent;
		public float ClickerRadiusColorMultiplier => clickerRadiusRangeAlpha * clickerRadiusSwitchAlpha;
		/// <summary>
		/// Visual (clientside) indicator that the cursor is inside clicker radius
		/// </summary>
		public bool clickerInRange = false;
		/// <summary>
		/// Visual (clientside) indicator that the cursor is inside Motherboard radius
		/// </summary>
		public bool clickerInRangeMotherboard = false;
		public bool GlowVisual => clickerInRange || clickerInRangeMotherboard;
		public bool clickerSelected = false;
		/// <summary>
		/// False if phase reach
		/// </summary>
		public bool clickerDrawRadius = false;
		public const float clickerRadiusSwitchAlphaMin = 0f;
		public const float clickerRadiusSwitchAlphaMax = 1f;
		public const float clickerRadiusSwitchAlphaStep = clickerRadiusSwitchAlphaMax / 40f;
		public float clickerRadiusSwitchAlpha = clickerRadiusSwitchAlphaMin;

		//Gameplay only: not related to player select screen
		public bool CanDrawRadius => !Main.gameMenu && !Player.dead && clickerRadiusSwitchAlpha > clickerRadiusSwitchAlphaMin;

		public const float clickerRadiusRangeAlphaMin = 0.2f;
		public const float clickerRadiusRangeAlphaMax = 0.8f;
		public const float clickerRadiusRangeAlphaStep = clickerRadiusRangeAlphaMax / 20f;
		public float clickerRadiusRangeAlpha = clickerRadiusRangeAlphaMin;

		/// <summary>
		/// Set via hotkey, reset if no autoclick-giving effects are applied (i.e. Hand Cream)
		/// <br/>Synced whenever changed
		/// </summary>
		public bool clickerAutoClick = false;
		/// <summary>
		/// Saved amount of clicks done with any clicker, accumulated, fluff
		/// </summary>
		public int clickerTotal = 0;
		/// <summary>
		/// Amount of clicks done, constantly incremented. Used for click effect proccing
		/// </summary>
		public int clickAmount = 0;
		/// <summary>
		/// cps, use Math.Floor if you need as integer
		/// </summary>
		public float clickerPerSecond = 0;
		private const int ClickTimerCount = 60;
		/// <summary>
		/// Keeps track of clicks done in the last <see cref="ClickTimerCount"/> ticks, tracked as separate timers
		/// </summary>
		private List<Ref<float>> clickTimers = new List<Ref<float>>();
		/// <summary>
		/// Amount of money generated by clicker items
		/// </summary>
		public int clickerMoneyGenerated = 0;
		/// <summary>
		/// Used for double tap dash effects
		/// </summary>
		public int clickerDoubleTap = 0;
		/// <summary>
		/// Used for cursor positioning and the Aimbot Module effect (and similar). Defaults to Main.MouseWorld otherwise
		/// </summary>
		public Vector2 clickerPosition = Main.MouseWorld;

		/// <summary>
		/// Represents the currently active (fastest) auto-reuse effect applied to the player
		/// </summary>
		public AutoReuseEffect ActiveAutoReuseEffect { get; private set; }

		/// <summary>
		/// Represents all auto-reuse effects applied this tick
		/// </summary>
		private List<AutoReuseEffect> AutoReuseEffects { get; set; } = new List<AutoReuseEffect>();

		//Click effects
		/// <summary>
		/// Used to track effect names that are currently active. Resets every tick
		/// </summary>
		private Dictionary<string, bool> ClickEffectActive = new Dictionary<string, bool>();

		public bool effectTranscend = false;

		public bool effectHotWings = false;
		public const int EffectHotWingsTimerMax = 70; //Full duration. Damage part excludes the fade time
		public const int EffectHotWingsTimerFadeStart = 30;
		public int effectHotWingsTimer = 0; //Gets set to max, counts down

		public const int EffectHotWingsFrameMax = 4;
		public int effectHotWingsFrame = 0;

		public bool DrawHotWings => effectHotWingsTimer > 0;

		//Out of combat
		public const int OutOfCombatTimeMax = 300;
		public bool OutOfCombat => outOfCombatTimer <= 0;
		public int outOfCombatTimer = 0;

		//Item
		public bool itemBurningSuperDeath = false;
		public bool itemDreamClicker = false;
		public int itemSeafoamClickerTimer = 0;
		public int itemSeafoamClickerHPS = 0;

		/// <summary>
		/// Used to reduce spawn rate of dream clickers once one is picked up
		/// </summary>
		public bool pickedUpDreamClicker = false;

		//Armor
		public int setAbilityDelayTimer = 0;
		public float setMotherboardRatio = 0f;
		public float setMotherboardAngle = 0f;
		/// <summary>
		/// Calculated after clickerRadius is calculated, and if the Motherboard set is worn
		/// </summary>
		public Vector2 setMotherboardPosition = Vector2.Zero;
		public float setMotherboardAlpha = 0f;
		public int setMotherboardFrame = 0;
		public bool setMotherboardFrameShift = false;
		public bool setMotherboard = false;
		public bool SetMotherboardPlaced => setMotherboard && setMotherboardRatio > 0;

		public bool setMice = false;
		public bool setPrecursor = false;
		public bool setOverclock = false;
		public bool setRGB = false;

		public int setPrecursorTimer = 0;

		//Acc
		public bool accEnchantedLED = false;
		public bool accEnchantedLED2 = false; //different visuals
		public Item accAMedalItem = null;
		public bool AccAMedal => accAMedalItem != null && !accAMedalItem.IsAir;
		public Item accFMedalItem = null;
		public bool AccFMedal => accFMedalItem != null && !accFMedalItem.IsAir;
		public Item accSMedalItem = null;
		public bool AccSMedal => accSMedalItem != null && !accSMedalItem.IsAir;
		public bool accGlassOfMilk = false;
		public Item accCookieItem = null;
		public bool accCookie = false;
		public bool accCookie2 = false; //different visuals
		public bool accClickingGlove = false;
		public bool accAncientClickingGlove = false;
		public bool accRegalClickingGlove = false;
		public bool accPortableParticleAccelerator = false; //"is wearing"
		public bool accPortableParticleAccelerator2 = false; //"is active", client only
		public bool IsPortableParticleAcceleratorActive => accPortableParticleAccelerator && accPortableParticleAccelerator2;
		public Item accGoldenTicketItem = null;
		public bool AccGoldenTicket => accGoldenTicketItem != null && !accGoldenTicketItem.IsAir;
		public bool accTriggerFinger = false;
		public bool accMouseTrap = false;
		public Item accPaperclipsItem = null;
		public bool AccPaperclips => accPaperclipsItem != null && !accPaperclipsItem.IsAir;
		public bool accHotKeychain = false;
		public bool accHotKeychain2 = false;
		public bool accButtonMasher = false;
		public bool accAimbotModule = false;
		public bool accAimbotModule2 = false;
		public bool accAimbotModule2Toggle = false; //If enabled, automatically seeks enemies
		public int accAimbotModule2ToggleTimer = 0; //To not do it every tick
		public bool accEnlarge = false;
		public bool accSFXButtonSoundboard = false;

		public int accAimbotModuleTarget = -1;
		public int accAimbotModuleFailsafe = 0;
		public float accAimbotModuleScale = 1f;
		public bool accAimbotModuleTargetInRange = false; //Controls the target being drawn greyed out
		public bool HasAimbotModuleTarget => accAimbotModuleTarget > -1 && accAimbotModuleFailsafe >= 10;
		public int accClickingGloveTimer = 0;
		public int accCookieTimer = 0;
		public int accAMedalAmount = 0; //Only updated clientside
		public int accFMedalAmount = 0; //Only updated clientside
		public int accSMedalAmount = 0; //Only updated clientside
		public float accMedalRot = 0f; //Unified rotation for all medals
		public int accPaperclipsAmount = 0;
		public int accHotKeychainTimer = 0;
		public int accHotKeychainAmount = 0;

		//Store item type mapped to stack
		private Dictionary<int, int> sfxButtons;

		//Stats
		/// <summary>
		/// How many less clicks are required to trigger an effect
		/// </summary>
		public int clickerBonus = 0;

		/// <summary>
		/// Multiplier to clicks required to trigger an effect
		/// </summary>
		public float clickerBonusPercent = 1f;

		/// <summary>
		/// Effective clicker radius in pixels when multiplied by 100
		/// </summary>
		public float clickerRadius = 1f;

		/// <summary>
		/// Cached clickerRadius for draw
		/// </summary>
		public float clickerRadiusDraw = 1f;

		/// <summary>
		/// Clicker radius in pixels
		/// </summary>
		public float ClickerRadiusReal => clickerRadius * 100;

		/// <summary>
		/// Clicker draw radius in pixels
		/// </summary>
		public float ClickerRadiusRealDraw => clickerRadiusDraw * 100;

		/// <summary>
		/// Motherboard radius in pixels
		/// </summary>
		public float ClickerRadiusMotherboard => ClickerRadiusReal * 0.5f;

		/// <summary>
		/// Motherboard draw radius in pixels
		/// </summary>
		public float ClickerRadiusMotherboardDraw => ClickerRadiusRealDraw * 0.5f;

		/// <summary>
		/// If player has consumed a Heavenly Chip and has its bonus clicker radius
		/// </summary>
		public bool consumedHeavenlyChip;

		//Need to be synced
		public bool paintingCondition_MoonLordDefeatedWithClicker;
		public bool paintingCondition_Clicked100Cookies; //Instead of server having to keep track of every clicked cookie, only set it once

		public int paintingCondition_ClickedCookiesCount;

		//Helper methods
		/// <summary>
		/// Enables the use of a click effect for this player
		/// </summary>
		/// <param name="name">The unique effect name</param>
		public void EnableClickEffect(string name)
		{
			if (ClickEffectActive.TryGetValue(name, out _))
			{
				ClickEffectActive[name] = true;
			}
		}

		/// <summary>
		/// Enables the use of click effects for this player
		/// </summary>
		/// <param name="names">The unique effect names</param>
		public void EnableClickEffect(IEnumerable<string> names)
		{
			foreach (var name in names)
			{
				EnableClickEffect(name);
			}
		}

		/// <summary>
		/// Checks if the player has a click effect enabled
		/// </summary>
		/// <param name="name">The unique effect name</param>
		/// <returns><see langword="true"/> if enabled</returns>
		public bool HasClickEffect(string name)
		{
			if (ClickEffectActive.TryGetValue(name, out _))
			{
				return ClickEffectActive[name];
			}
			return false;
		}

		/// <summary>
		/// Checks if the player has a click effect enabled
		/// </summary>
		/// <param name="name">The unique effect name</param>
		/// <param name="effect">The effect associated with the name</param>
		/// <returns><see langword="true"/> if enabled</returns>
		public bool HasClickEffect(string name, out ClickEffect effect)
		{
			effect = null;
			if (HasClickEffect(name))
			{
				return ClickerSystem.IsClickEffect(name, out effect);
			}
			return false;
		}

		//Unused yet
		public bool HasAnyClickEffect()
		{
			foreach (var value in ClickEffectActive.Values)
			{
				if (value) return true;
			}
			return false;
		}

		internal void ResetAllClickEffects()
		{
			//Stupid trick to be able to write to a value in a dictionary
			foreach (var key in ClickEffectActive.Keys.ToList())
			{
				ClickEffectActive[key] = false;
			}
		}

		/// <summary>
		/// Adds the given auto-reuse effect to the list of available effects applicable this tick, aswell as deciding on the fastest one to use
		/// </summary>
		internal void SetAutoReuseEffect(AutoReuseEffect effect)
		{
			AutoReuseEffects.Add(effect);

			//Pick the fastest one available
			for (int i = 0; i < AutoReuseEffects.Count; i++)
			{
				var iter = AutoReuseEffects[i];
				if (iter.ControlledByKeyBind && !clickerAutoClick)
				{
					//"Not enabled", skip
					continue;
				}

				//Pick if none, or faster than current
				if (ActiveAutoReuseEffect == default || iter.SpeedFactor < ActiveAutoReuseEffect.SpeedFactor)
				{
					ActiveAutoReuseEffect = iter;
				}
			}
		}

		internal void ResetAutoClickToggle()
		{
			if (!AutoReuseEffects.Any(effect => effect.ControlledByKeyBind))
			{
				//If no reuse effects need the keybind, unset the toggle
				clickerAutoClick = false;
			}
		}

		/// <summary>
		/// Call to register a click towards the "clicks per second" and total calculations
		/// </summary>
		internal void AddClick()
		{
			clickTimers.Add(new Ref<float>(1f));
			clickerTotal++;
		}

		/// <summary>
		/// Call to increment the click amount counter used for proccing click effects
		/// </summary>
		internal void AddClickAmount()
		{
			clickAmount++;
			int sMedalStep = SMedal.ChargeMeterStep;
			if (accSMedalAmount >= sMedalStep)
			{
				accSMedalAmount -= sMedalStep;
			}
		}

		/// <summary>
		/// Manages the click queue and calculates <see cref="clickerPerSecond"/>
		/// </summary>
		private void HandleCPS()
		{
			clickerPerSecond = 0f; //Recalculates every tick

			//Loop from back to front, removing ran out timers and adding existing timers
			for (int i = clickTimers.Count - 1; i >= 0; i--)
			{
				clickTimers[i].Value -= 1f / ClickTimerCount; //Decrement timer
				if (clickTimers[i].Value <= 0f)
				{
					clickTimers.RemoveAt(i);
				}
				else
				{
					float value = clickTimers[i].Value;
					value = Math.Clamp(value, 0.3f, 0.75f); //Smooths out the values, with slight bias towards > 0.5f, so that the cps stays on a given value longer if clicks are regular (i.e. autoswing)
					clickerPerSecond += value * 2; //* 2 is because the average click timer "state" is 0.5f
				}
			}

			clickerPerSecond = Math.Clamp(clickerPerSecond, 0, 60);
		}

		private void HandleRadiusAlphas()
		{
			if (clickerDrawRadius)
			{
				if (clickerRadiusSwitchAlpha < clickerRadiusSwitchAlphaMax)
				{
					clickerRadiusSwitchAlpha += clickerRadiusSwitchAlphaStep;
				}
				else
				{
					clickerRadiusSwitchAlpha = clickerRadiusSwitchAlphaMax;
				}
			}
			else
			{
				if (clickerRadiusSwitchAlpha > clickerRadiusSwitchAlphaMin)
				{
					clickerRadiusSwitchAlpha -= clickerRadiusSwitchAlphaStep;
				}
				else
				{
					clickerRadiusSwitchAlpha = clickerRadiusSwitchAlphaMin;
				}
			}

			if (GlowVisual)
			{
				if (clickerRadiusRangeAlpha < clickerRadiusRangeAlphaMax)
				{
					clickerRadiusRangeAlpha += clickerRadiusRangeAlphaStep;
				}
				else
				{
					clickerRadiusRangeAlpha = clickerRadiusRangeAlphaMax;
				}
			}
			else
			{
				if (clickerRadiusRangeAlpha > clickerRadiusRangeAlphaMin)
				{
					clickerRadiusRangeAlpha -= clickerRadiusRangeAlphaStep;
				}
				else
				{
					clickerRadiusRangeAlpha = clickerRadiusRangeAlphaMin;
				}
			}
		}

		private void HandleAimbotModuleTargeting()
		{
			if (accAimbotModuleFailsafe < 10)
			{
				ResetAimbotModuleTarget();
				accAimbotModuleFailsafe++;
			}

			if (accAimbotModuleScale > 1f)
			{
				accAimbotModuleScale -= 0.05f;
			}

			if (accAimbotModule2)
			{
				if (accAimbotModule2Toggle && !HasAimbotModuleTarget && clickerSelected)
				{
					accAimbotModule2ToggleTimer++;
					if (accAimbotModule2ToggleTimer > 5)
					{
						accAimbotModule2ToggleTimer = 0;
						AimbotModuleTargestClosest();
					}
				}
			}
			else
			{
				accAimbotModule2Toggle = false;
			}

			//No target: return
			if (!HasAimbotModuleTarget)
			{
				return;
			}

			//No aimbot giving accessories equipped: reset and return
			if (!(accAimbotModule || accAimbotModule2))
			{
				ResetAimbotModuleTarget();
				return;
			}

			accAimbotModuleTargetInRange = clickerSelected;

			NPC target = Main.npc[accAimbotModuleTarget];
			clickerPosition = target.Center;
			CheckPositionInRange(target.Center, out bool targetInRange, out bool targetInRangeMotherboard);
			bool targetInRangeCombined = targetInRange || targetInRangeMotherboard;

			//If target still alive (keeps target until death)
			bool keepTargetCheck = target.active;
			if (accAimbotModule2)
			{
				//Or if target still targetable (moonlord hand, granite golem etc.)
				keepTargetCheck = target.CanBeChasedBy();
			}

			if (keepTargetCheck && targetInRangeCombined)
			{
				return;
			}

			if (!keepTargetCheck)
			{
				ResetAimbotModuleTarget();
			}

			bool canRetarget = accAimbotModule2 && clickerSelected;
			if (!targetInRangeCombined)
			{
				accAimbotModuleTargetInRange = false; //Target out of range, go inactive

				float radiusSQ = 1920; //Use doubled screen width check for hardcoded retargeting if outside
				radiusSQ *= radiusSQ;
				if (target.DistanceSQ(Player.Center) >= radiusSQ)
				{
					ResetAimbotModuleTarget(); //Target too far away, reset
					canRetarget = false;
				}
			}

			if (!canRetarget)
			{
				return;
			}

			AimbotModuleTargestClosest();
		}

		private void AimbotModuleTargestClosest()
		{
			//Retarget to closest enemy to either the old target or the player
			NPC nearOldTarget = null;
			float oldToDistSQMax = float.MaxValue;
			NPC nearPlayerTarget = null;
			float playerToDistSQMax = float.MaxValue;
			for (int i = 0; i < Main.maxNPCs; i++)
			{
				NPC newTarget = Main.npc[i];
				if (newTarget.CanBeChasedBy())
				{
					CheckPositionInRange(newTarget.Center, out bool newTargetInRange, out bool newTargetInRangeMotherboard);
					bool newTargetInRangeCombined = newTargetInRange || newTargetInRangeMotherboard;
					if (!newTargetInRangeCombined)
					{
						//Skip enemies not clicker radius
						continue;
					}

					float toOldDistSQ = newTarget.DistanceSQ(clickerPosition);
					if (toOldDistSQ < oldToDistSQMax)
					{
						oldToDistSQMax = toOldDistSQ;
						nearOldTarget = newTarget;
					}

					float toPlayerDistSQ = newTarget.DistanceSQ(Player.Center);
					if (toPlayerDistSQ < playerToDistSQMax)
					{
						playerToDistSQMax = toPlayerDistSQ;
						nearPlayerTarget = newTarget;
					}
				}
			}

			NPC preferredTarget = null;
			if (nearPlayerTarget != null)
			{
				preferredTarget = nearPlayerTarget;
			}

			if (nearOldTarget != null && oldToDistSQMax < playerToDistSQMax)
			{
				preferredTarget = nearOldTarget;
			}

			if (preferredTarget != null)
			{
				SetAimbotModuleTarget(preferredTarget);
			}
		}

		/// <summary>
		/// Returns the position from the ratio and angle, given the radius in pixels
		/// </summary>
		/// <param name="realRadius">The reference radius</param>
		public Vector2 CalculateMotherboardPosition(float realRadius)
		{
			float length = setMotherboardRatio * realRadius;
			Vector2 direction = setMotherboardAngle.ToRotationVector2();
			return direction * length;
		}

		/// <summary>
		/// Construct ratio and angle from position
		/// </summary>
		public void SetMotherboardRelativePosition(Vector2 position)
		{
			Vector2 toPosition = position - Player.Center;
			float length = toPosition.Length();
			float radius = ClickerRadiusReal;
			float ratio = length / radius;
			if (ratio < 0.6f)
			{
				//Enforce minimal range
				ratio = 0.6f;
			}
			setMotherboardRatio = ratio;
			setMotherboardAngle = toPosition.ToRotation();
		}

		/// <summary>
		/// Dispels the motherboard position
		/// </summary>
		public void ResetMotherboardPosition()
		{
			setMotherboardPosition = Vector2.Zero;
			setMotherboardRatio = 0f;
			setMotherboardAngle = 0f;
		}

		/// <summary>
		/// For checking if the given position is in range of the clicker radius (and by default, the motherboard set position)
		/// </summary>
		public void CheckPositionInRange(Vector2 position, out bool inRange, out bool inRangeMotherboard, bool checkMotherboard = true)
		{
			inRange = false;
			inRangeMotherboard = false;
			float radiusSQ = ClickerRadiusReal * ClickerRadiusReal;

			bool? collision = null; //Since it uses the same collision check twice, but it shouldn't just be calculated twice too

			if (Vector2.DistanceSquared(position, Player.Center) < radiusSQ)
			{
				collision = Collision.CanHit(new Vector2(Player.Center.X, Player.Center.Y - 12), 1, 1, position, 1, 1);
				if (collision == true)
				{
					inRange = true;
				}
			}

			if (!checkMotherboard || !SetMotherboardPlaced)
			{
				return;
			}

			radiusSQ = ClickerRadiusMotherboard * ClickerRadiusMotherboard;
			if (Vector2.DistanceSquared(position, setMotherboardPosition) < radiusSQ)
			{
				collision ??= Collision.CanHit(new Vector2(Player.Center.X, Player.Center.Y - 12), 1, 1, position, 1, 1);
				if (collision == true)
				{
					inRangeMotherboard = true;
				}
			}
		}

		public void SetAimbotModuleTarget(NPC target)
		{
			accAimbotModuleTarget = target.whoAmI;
			accAimbotModuleScale = 2f;
			accAimbotModuleTargetInRange = true;
		}

		public void ResetAimbotModuleTarget()
		{
			accAimbotModuleTarget = -1;
			accAimbotModuleTargetInRange = false;
		}

		internal int originalSelectedItem;
		internal bool autoRevertSelectedItem = false;

		/// <summary>
		/// Uses the item in the specified index from the players inventory
		/// </summary>
		public void QuickUseItemInSlot(int index)
		{
			if (index > -1 && index < Main.InventorySlotsTotal && Player.inventory[index].type != ItemID.None)
			{
				if (Player.CheckMana(Player.inventory[index], -1, false, false))
				{
					originalSelectedItem = Player.selectedItem;
					autoRevertSelectedItem = true;
					Player.selectedItem = index;
					Player.controlUseItem = true;
					Player.ItemCheck();
				}
				else
				{
					SoundEngine.PlaySound(SoundID.Drip with { Variants = stackalloc int[] { 0, 1, 2 } }, Player.Center);
				}
			}
		}

		/// <summary>
		/// Returns the amount of clicks required for an effect of the given name to trigger (defaults to the item's assigned effect). Includes various bonuses
		/// </summary>
		public int GetClickAmountTotal(ClickerItemCore clickerItem, string name)
		{
			//Doesn't go below 1
			int amount = 1;
			if (ClickerSystem.IsClickEffect(name, out ClickEffect effect))
			{
				amount = effect.Amount;
			}
			float percent = Math.Max(0f, clickerBonusPercent);
			int prePercentAmount = Math.Max(1, amount + clickerItem.clickBoostPrefix - clickerBonus);
			return Math.Max(1, (int)(prePercentAmount * percent));
		}

		/// <summary>
		/// Returns the amount of clicks required for the effect of this item to trigger. Includes various bonuses
		/// </summary>
		public int GetClickAmountTotal(Item item, string name)
		{
			if (item.TryGetGlobalItem(out ClickerItemCore clickerItem))
			{
				return GetClickAmountTotal(clickerItem, name);
			}
			return 1;
		}

		/// <summary>
		/// Counts the stack of the given <paramref name="item"/> up by its stack<br/>
		/// Returns true if reached <see cref="SFXButtonBase.StackAmount"/>
		/// </summary>
		public bool AddSFXButtonStack(Item item)
		{
			return AddSFXButtonStack(item.type, item.stack);
		}

		/// <summary>
		/// Counts the stack of the given item type up by <paramref name="stack"/><br/>
		/// Returns true if reached <see cref="SFXButtonBase.StackAmount"/>
		/// </summary>
		public bool AddSFXButtonStack(int type, int stack)
		{
			if (!ClickerSystem.IsSFXButton(type))
			{
				return false;
			}

			if (!sfxButtons.ContainsKey(type))
			{
				sfxButtons[type] = 0;
			}

			sfxButtons[type] = Math.Min(SFXButtonBase.StackAmount, sfxButtons[type] + stack);
			return sfxButtons[type] == SFXButtonBase.StackAmount;
		}

		/// <summary>
		/// Assigns <paramref name="stack"/> of the given type, if returning true<br/>
		/// </summary>
		public bool GetSFXButtonStack(int type, out int stack)
		{
			return sfxButtons.TryGetValue(type, out stack);
		}

		/// <summary>
		/// Returns all currently active "sfx button" stacks.<br/>
		/// Use with <see cref="ClickerSystem.IsSFXButton"/> to get the sound
		/// </summary>
		public IReadOnlyDictionary<int, int> GetAllSFXButtonStacks()
		{
			return sfxButtons;
		}

		public override void ResetEffects()
		{
			//-Clicker-
			//Misc
			clickerRadiusColor = Color.White;
			clickerInRange = false;
			clickerInRangeMotherboard = false;
			clickerSelected = false;
			clickerDrawRadius = false;

			ActiveAutoReuseEffect = default;
			AutoReuseEffects.Clear();

			//Click Effects
			ResetAllClickEffects();
			effectHotWings = false;
			effectTranscend = false;

			//Item
			itemBurningSuperDeath = false;
			itemDreamClicker = false;

			//Armor
			setMotherboard = false;
			setMice = false;
			setPrecursor = false;
			setOverclock = false;
			setRGB = false;

			//Acc
			accEnchantedLED = false;
			accEnchantedLED2 = false;
			accAMedalItem = null;
			accFMedalItem = null;
			accSMedalItem = null;
			accGlassOfMilk = false;
			accCookieItem = null;
			accCookie = false;
			accCookie2 = false;
			accClickingGlove = false;
			accAncientClickingGlove = false;
			accRegalClickingGlove = false;
			accPortableParticleAccelerator = false;
			accPortableParticleAccelerator2 = false;
			accGoldenTicketItem = null;
			accTriggerFinger = false;
			accMouseTrap = false;
			accPaperclipsItem = null;
			accHotKeychain = false;
			accHotKeychain2 = false;
			accAimbotModule = false;
			accAimbotModule2 = false;
			accAimbotModuleTargetInRange = false;
			accEnlarge = false;
			accSFXButtonSoundboard = false;

			sfxButtons.Clear();

			//Stats
			clickerBonus = 0;
			clickerBonusPercent = 1f;
			clickerRadius = 1f;
		}

		public override void ResetInfoAccessories()
		{
			accButtonMasher = false;
		}

		public override void UpdateAutopause()
		{
			clickerRadius = 1f;
		}

		public override void Initialize()
		{
			clickerTotal = 0;
			clickerMoneyGenerated = 0;

			paintingCondition_MoonLordDefeatedWithClicker = false;
			paintingCondition_Clicked100Cookies = false;
			paintingCondition_ClickedCookiesCount = 0;

			AutoReuseEffects = new List<AutoReuseEffect>();

			ClickEffectActive = new Dictionary<string, bool>();
			foreach (var name in ClickerSystem.GetAllEffectNames())
			{
				ClickEffectActive.Add(name, false);
			}

			clickTimers = new List<Ref<float>>();

			sfxButtons = new Dictionary<int, int>();
		}

		public override void SaveData(TagCompound tag)
		{
			tag.Add("clickerTotal", clickerTotal);
			tag.Add("clickerMoneyGenerated", clickerMoneyGenerated);
			tag.Add("consumedHeavenlyChip", consumedHeavenlyChip);
			tag.Add("paintingCondition_MoonLordDefeatedWithClicker", paintingCondition_MoonLordDefeatedWithClicker);
			tag.Add("paintingCondition_Clicked100Cookies", paintingCondition_Clicked100Cookies);
			tag.Add("paintingCondition_ClickedCookiesCount", paintingCondition_ClickedCookiesCount);
			tag.Add("pickedUpDreamClicker", pickedUpDreamClicker);
		}

		public override void LoadData(TagCompound tag)
		{
			clickerTotal = tag.GetInt("clickerTotal");
			clickerMoneyGenerated = tag.GetInt("clickerMoneyGenerated");
			consumedHeavenlyChip = tag.GetBool("consumedHeavenlyChip");
			paintingCondition_MoonLordDefeatedWithClicker = tag.GetBool("paintingCondition_MoonLordDefeatedWithClicker");
			paintingCondition_Clicked100Cookies = tag.GetBool("paintingCondition_Clicked100Cookies");
			paintingCondition_ClickedCookiesCount = tag.GetInt("paintingCondition_ClickedCookiesCount");
			pickedUpDreamClicker = tag.GetBool("pickedUpDreamClicker");
		}

		public override void CopyClientState(ModPlayer clientClone)
		{
			var clickerClone = clientClone as ClickerPlayer;

			clickerClone.clickerAutoClick = clickerAutoClick;
		}

		public override void SendClientChanges(ModPlayer clientPlayer)
		{
			var clickerClone = clientPlayer as ClickerPlayer;

			if (clickerClone.clickerAutoClick != clickerAutoClick)
			{
				new ClickerAutoClickPacket(Player, clickerAutoClick).Send();
			}
		}

		public override void SyncPlayer(int toWho, int fromWho, bool newPlayer)
		{
			new SyncClickerPlayerPacket(this).Send(toWho, fromWho);
		}

		public override void RefreshInfoAccessoriesFromTeamPlayers(Player otherPlayer)
		{
			ClickerPlayer clickerOther = otherPlayer.GetModPlayer<ClickerPlayer>();
			if (clickerOther.accButtonMasher)
			{
				accButtonMasher = true;
			}
		}

		public override void ProcessTriggers(TriggersSet triggersSet)
		{
			// checks for frozen, webbed and stoned
			if (Player.CCed)
			{
				return;
			}

			if (ClickerClass.AutoClickKey.JustPressed)
			{
				if (Math.Abs(clickerClassTime - pressedAutoClick) > 20)
				{
					pressedAutoClick = clickerClassTime;

					if (AutoReuseEffects.Any(effect => effect.ControlledByKeyBind))
					{
						SoundEngine.PlaySound(SoundID.MenuTick, Player.position);
						clickerAutoClick = !clickerAutoClick;
					}
				}
			}
			if (ClickerClass.AimAssistKey.JustPressed)
			{
				if (accAimbotModule)
				{
					SoundEngine.PlaySound(SoundID.MenuTick, Player.position);

					if (accAimbotModule2)
					{
						if (accAimbotModule2Toggle)
						{
							accAimbotModule2Toggle = false;
							ResetAimbotModuleTarget();
						}
						else
						{
							accAimbotModule2Toggle = true;
						}
					}
					else
					{
						for (int i = 0; i < Main.maxNPCs; i++)
						{
							NPC target = Main.npc[i];
							if (target.CanBeChasedBy())
							{
								Rectangle inflatedHitbox = target.getRect();
								inflatedHitbox.Inflate(50, 50);
								if (inflatedHitbox.Contains(Main.MouseWorld.ToPoint()))
								{
									SetAimbotModuleTarget(target);
									break;
								}
							}
						}
					}
				}
			}
		}

		public override void PreUpdate()
		{
			if (Player.whoAmI == Main.myPlayer)
			{
				if (autoRevertSelectedItem)
				{
					if (Player.itemTime == 0 && Player.itemAnimation == 0)
					{
						Player.selectedItem = originalSelectedItem;
						autoRevertSelectedItem = false;
					}
				}
			}

			if (Player.whoAmI == Main.myPlayer)
			{
				if (Player.itemTime == 0 && Player.itemAnimation == 0)
				{
					if (accRegalClickingGlove && accClickingGloveTimer > 30)
					{
						QuickUseItemInSlot(Player.selectedItem);
						accClickingGloveTimer = 0;
					}
					else if (accAncientClickingGlove && accClickingGloveTimer > 60)
					{
						QuickUseItemInSlot(Player.selectedItem);
						accClickingGloveTimer = 0;
					}
					else if (accClickingGlove && accClickingGloveTimer > 120)
					{
						QuickUseItemInSlot(Player.selectedItem);
						accClickingGloveTimer = 0;
					}
				}
			}
		}

		public override void PostUpdateEquips()
		{
			clickerClassTime++;
			if (clickerClassTime > 36000)
			{
				clickerClassTime = 0;
			}

			ResetAutoClickToggle();
			
			//Handle Seafoam health timer
			if (itemSeafoamClickerHPS > 0)
			{
				itemSeafoamClickerTimer++;
				if (itemSeafoamClickerTimer >= 60)
				{
					itemSeafoamClickerHPS = 0;
					itemSeafoamClickerTimer = 0;
				}
			}

			if (setAbilityDelayTimer > 0)
			{
				setAbilityDelayTimer--;
			}

			//Shimmer Clicker item handle
			if (consumedHeavenlyChip)
			{
				clickerRadius += 2 * HeavenlyChip.RadiusIncrease / 100f;
			}

			if (!setMotherboard)
			{
				ResetMotherboardPosition();
			}
			else
			{
				setMotherboardAlpha += !setMotherboardFrameShift ? 0.025f : -0.025f;
				if (setMotherboardAlpha >= 1f)
				{
					setMotherboardFrameShift = true;
				}

				if (setMotherboardFrameShift && setMotherboardAlpha <= 0.25f)
				{
					setMotherboardFrame++;
					if (setMotherboardFrame >= 4)
					{
						setMotherboardFrame = 0;
					}
					setMotherboardFrameShift = false;
				}
			}

			clickerRadius += 0.005f * accFMedalAmount;

			Item heldItem = Player.HeldItem;
			if (ClickerSystem.IsClickerWeapon(heldItem, out ClickerItemCore clickerItem))
			{
				EnableClickEffect(clickerItem.itemClickEffects);
				clickerSelected = true;
				clickerDrawRadius = true;
				if (HasClickEffect(ClickEffect.PhaseReach))
				{
					clickerRadiusSwitchAlpha = clickerRadiusSwitchAlphaMin;
					clickerDrawRadius = false;
				}

				if (clickerItem.radiusBoost > 0f)
				{
					clickerRadius += clickerItem.radiusBoost;
				}

				if (clickerItem.radiusBoostPrefix > 0f)
				{
					clickerRadius += clickerItem.radiusBoostPrefix;
				}

				//Cache for draw
				clickerRadiusDraw = clickerRadius;

				if (setMotherboard)
				{
					//Important: has to be after final clickerRadius calculation because it depends on it
					setMotherboardPosition = Player.Center + CalculateMotherboardPosition(ClickerRadiusReal);
				}

				//Collision
				CheckPositionInRange(Main.MouseWorld, out bool inRange, out bool inRangeMotherboard);
				clickerInRange = inRange;
				clickerInRangeMotherboard = inRangeMotherboard;

				clickerRadiusColor = clickerItem.clickerRadiusColor;

				//Cache for draw
				clickerRadiusColorDraw = Color.Lerp(clickerRadiusColorDraw, clickerRadiusColor, clickerRadiusSwitchAlpha);

				//Glove acc
				if (!OutOfCombat && (accClickingGlove || accAncientClickingGlove || accRegalClickingGlove))
				{
					accClickingGloveTimer++;
				}
				else
				{
					accClickingGloveTimer = 0;
				}

				if (setPrecursor && !OutOfCombat && clickerInRange)
				{
					setPrecursorTimer++;
					if (setPrecursorTimer > 5)
					{
						if (Main.myPlayer == Player.whoAmI)
						{
							int damage = Math.Max(1, (int)(heldItem.damage * 0.25f));
							Projectile.NewProjectile(Player.GetSource_FromThis(context: "Set_Precursor"), clickerPosition.X + 8, clickerPosition.Y + 11, 0f, 0f, ModContent.ProjectileType<PrecursorPro>(), damage, 0f, Player.whoAmI);
						}
						setPrecursorTimer = 0;
					}
				}
				else
				{
					setPrecursorTimer = 0;
				}
			}
			else
			{
				clickerRadiusColorDraw = Color.Lerp(Color.Transparent, clickerRadiusColorDraw, clickerRadiusSwitchAlpha);
			}

			if (Player.HasBuff(ModContent.BuffType<Haste>()))
			{
				Player.armorEffectDrawShadow = true;
			}

			if (clickerDoubleTap > 0)
			{
				clickerDoubleTap--;
			}

			//Clicker Effects
			//Hot Wings
			if (effectHotWings && Player.grappling[0] == -1 && !Player.tongued)
			{
				int dashDir = 0;
				if (Player.controlRight && Player.releaseRight)
				{
					clickerDoubleTap += clickerDoubleTap > 0 ? 0 : 15;
					if (clickerDoubleTap < 15 && clickerDoubleTap > 0)
					{
						dashDir = 1;
					}
				}
				else if (Player.controlLeft && Player.releaseLeft)
				{
					clickerDoubleTap += clickerDoubleTap > 0 ? 0 : 15;
					if (clickerDoubleTap < 15 && clickerDoubleTap > 0)
					{
						dashDir = -1;
					}
				}

				if (Math.Abs(dashDir) == 1)
				{
					effectHotWingsTimer = EffectHotWingsTimerMax;

					SoundEngine.PlaySound(SoundID.Item73, Player.Center);
					Player.ClearBuff(ModContent.BuffType<HotWingsBuff>());
					//if (Player.velocity.Y > 0f) Player.velocity.Y = 0f;
					//if (Player.velocity.X < 0f) Player.velocity.X = 0f;
					Player.velocity.Y -= 6f;
					Player.velocity.X = dashDir * 12f;
					Player.ChangeDir(dashDir);

					//Vanilla code
					Point point3 = (Player.Center + new Vector2(dashDir * Player.width / 2 + 2, Player.gravDir * -Player.height / 2f + Player.gravDir * 2f)).ToTileCoordinates();
					Point point4 = (Player.Center + new Vector2(dashDir * Player.width / 2 + 2, 0f)).ToTileCoordinates();
					if (WorldGen.SolidOrSlopedTile(point3.X, point3.Y) || WorldGen.SolidOrSlopedTile(point4.X, point4.Y))
					{
						Player.velocity.X /= 2f;
					}

					for (int k = 0; k < 15; k++)
					{
						Dust dust = Dust.NewDustDirect(Player.position, Player.width, Player.height, 174, Main.rand.NextFloat(-5f, 5f), Main.rand.NextFloat(-5f, 5f), 0, default, 1.25f);
						dust.noGravity = true;
						dust.noLight = true;
					}
				}
			}

			if (effectHotWingsTimer > 0)
			{
				effectHotWingsTimer--;

				if (effectHotWingsTimer % 6 == 0)
				{
					effectHotWingsFrame++;
					if (effectHotWingsFrame >= EffectHotWingsFrameMax)
					{
						effectHotWingsFrame = 0;
					}
				}
			}
			else
			{
				effectHotWingsFrame = 0;
			}

			//Acc
			//Aimbot Module
			HandleAimbotModuleTargeting();

			if (!accAimbotModuleTargetInRange)
			{
				clickerPosition = Main.MouseWorld;
			}

			//Cookie acc
			if (accCookieItem != null && !accCookieItem.IsAir && (accCookie || accCookie2) && clickerSelected)
			{
				accCookieTimer++;
				if (Player.whoAmI == Main.myPlayer && accCookieTimer > 600)
				{
					int radius = (int)(95 * clickerRadius);
					if (radius > 350)
					{
						radius = 350;
					}

					//Sqrt for bias outwards
					Vector2 pos = Vector2.UnitY.RotatedByRandom(MathHelper.TwoPi) * radius * (float)Math.Sqrt(Main.rand.NextFloat(0.1f, 1f));

					Projectile.NewProjectile(Player.GetSource_Accessory(accCookieItem), pos + Player.Center, Vector2.Zero, ModContent.ProjectileType<CookiePro>(), 0, 0f, Player.whoAmI);

					accCookieTimer = 0;
				}

				//Cookie Click
				if (Player.whoAmI == Main.myPlayer)
				{
					int cookieType = ModContent.ProjectileType<CookiePro>();
					for (int i = 0; i < Main.maxProjectiles; i++)
					{
						Projectile proj = Main.projectile[i];

						if (proj.active && proj.owner == Player.whoAmI && proj.type == cookieType && proj.ModProjectile is CookiePro cookie)
						{
							if (Main.mouseLeft && Main.mouseLeftRelease && proj.DistanceSQ(Main.MouseWorld) < 30 * 30)
							{
								if (cookie.Frame == 1)
								{
									SoundEngine.PlaySound(SoundID.Item4, Player.Center);
									Player.AddBuff(ModContent.BuffType<CookieBuff>(), 600);
									Player.HealLife(10);
									for (int k = 0; k < 10; k++)
									{
										Dust dust = Dust.NewDustDirect(proj.Center, 20, 20, 87, Main.rand.NextFloat(-3f, 3f), Main.rand.NextFloat(-3f, 3f), 0, default, 1.15f);
										dust.noGravity = true;
									}
								}
								else
								{
									SoundEngine.PlaySound(SoundID.Item2, Player.Center);
									Player.AddBuff(ModContent.BuffType<CookieBuff>(), 300);
									for (int k = 0; k < 10; k++)
									{
										Dust dust = Dust.NewDustDirect(proj.Center, 20, 20, 0, Main.rand.NextFloat(-4f, 4f), Main.rand.NextFloat(-4f, 4f), 75, default, 1.5f);
										dust.noGravity = true;
									}
								}

								paintingCondition_ClickedCookiesCount++;
								if (paintingCondition_ClickedCookiesCount == 100)
								{
									paintingCondition_Clicked100Cookies = true;
									if (Main.netMode == NetmodeID.MultiplayerClient)
									{
										new Clicked100CookiesPacket(Player).Send();
									}
								}

								proj.Kill();
							}
						}
					}
				}
			}

			//Portable Particle Accelerator acc
			if (accPortableParticleAccelerator && Main.myPlayer == Player.whoAmI)
			{
				float radius = ClickerRadiusReal * PortableParticleAccelerator.InnerRadiusRatio / 100f; //No need to check motherboard as that isn't ever relevant with < 100% the radius
				if (Player.DistanceSQ(clickerPosition) < radius * radius)
				{
					accPortableParticleAccelerator2 = true;
				}
			}

			if (IsPortableParticleAcceleratorActive)
			{
				Player.GetDamage<ClickerDamage>().Flat += 8;
			}

			//Effects related to having cursor within the radius
			if (Player.whoAmI == Main.myPlayer)
			{
				if (clickerInRange && clickerSelected)
				{
					int balloonType = ModContent.ProjectileType<BalloonClickerPro>();
					int parachuteType = ModContent.ProjectileType<NaughtyClickerPro>();
					for (int i = 0; i < Main.maxProjectiles; i++)
					{
						//Balloon Defense effect
						Projectile proj = Main.projectile[i];

						if (proj.active && proj.owner == Player.whoAmI && proj.type == balloonType &&
							proj.ModProjectile is BalloonClickerPro balloon && !balloon.HasChanged && !balloon.Trigger)
						{
							if (Main.mouseLeft && Main.mouseLeftRelease && proj.DistanceSQ(new Vector2(Main.MouseWorld.X, Main.MouseWorld.Y + 40)) < 30 * 30)
							{
								balloon.Trigger = true; //Handled in the AI
							}
						}

						//Present effect
						if (proj.active && proj.owner == Player.whoAmI && proj.type == parachuteType && proj.frame == 1 &&
						proj.ModProjectile is NaughtyClickerPro parachute && !parachute.HasChanged && !parachute.Trigger)
						{
							if (Main.mouseLeft && Main.mouseLeftRelease && proj.DistanceSQ(Main.MouseWorld) < 30 * 30)
							{
								parachute.Trigger = true; //Handled in the AI
							}
						}
					}
				}

				//A Medal effect
				if (accAMedalAmount < AMedal.ChargeMeterMax && clickerSelected && AccAMedal)
				{
					int aMedalType = ModContent.ProjectileType<AMedalPro>();
					for (int i = 0; i < Main.maxProjectiles; i++)
					{
						Projectile proj = Main.projectile[i];

						if (proj.active && proj.owner == Player.whoAmI && proj.type == aMedalType && proj.ModProjectile is MedalProBase medal)
						{
							float len = (proj.Size / 2f).LengthSquared() * 0.78f; //Circle inside the projectile hitbox
							if (proj.DistanceSQ(Main.MouseWorld) < len)
							{
								accAMedalAmount += 2;
								medal.MouseoverAlpha = 1f;
								Vector2 offset = new Vector2(Main.rand.Next(-20, 21), Main.rand.Next(-20, 21));
								Dust dust = Dust.NewDustDirect(Main.MouseWorld + offset, 8, 8, 86, Scale: 1.25f);
								dust.noGravity = true;
								dust.velocity = -offset * 0.05f;
							}
						}
					}
				}

				//F Medal effect
				if (accFMedalAmount < FMedal.ChargeMeterMax && clickerSelected && AccFMedal)
				{
					int fMedalType = ModContent.ProjectileType<FMedalPro>();
					for (int i = 0; i < Main.maxProjectiles; i++)
					{
						Projectile proj = Main.projectile[i];

						if (proj.active && proj.owner == Player.whoAmI && proj.type == fMedalType && proj.ModProjectile is MedalProBase medal)
						{
							float len = (proj.Size / 2f).LengthSquared() * 0.78f; //Circle inside the projectile hitbox
							if (proj.DistanceSQ(Main.MouseWorld) < len)
							{
								accFMedalAmount += 2;
								medal.MouseoverAlpha = 1f;
								Vector2 offset = new Vector2(Main.rand.Next(-20, 21), Main.rand.Next(-20, 21));
								Dust dust = Dust.NewDustDirect(Main.MouseWorld + offset, 8, 8, 173, Scale: 1.25f);
								dust.noGravity = true;
								dust.velocity = -offset * 0.05f;
							}
						}
					}
				}

				//S Medal effect
				if (clickerSelected && AccSMedal)
				{
					int sMedalType1 = ModContent.ProjectileType<SMedalPro>();
					int sMedalType2 = ModContent.ProjectileType<SMedalPro2>();
					int sMedalType3 = ModContent.ProjectileType<SMedalPro3>();

					for (int i = 0; i < Main.maxProjectiles; i++)
					{
						Projectile proj = Main.projectile[i];

						if (proj.active && proj.owner == Player.whoAmI && (proj.type == sMedalType1 || proj.type == sMedalType2 || proj.type == sMedalType3) && proj.ModProjectile is SMedalProBase sMedal)
						{
							float len = (proj.Size / 2f).LengthSquared() * 0.78f; //Circle inside the projectile hitbox
							if (proj.DistanceSQ(Main.MouseWorld) < len)
							{
								if (proj.type == sMedalType1 && accFMedalAmount < FMedal.ChargeMeterMax) //F Medal Equivalent
								{
									accFMedalAmount += 3;
									sMedal.MouseoverAlpha = 1f;
									Vector2 offset = new Vector2(Main.rand.Next(-20, 21), Main.rand.Next(-20, 21));
									Dust dust = Dust.NewDustDirect(Main.MouseWorld + offset, 8, 8, 88, Scale: 1.25f);
									dust.noGravity = true;
									dust.velocity = -offset * 0.05f;
								}
								if (proj.type == sMedalType2 && accAMedalAmount < AMedal.ChargeMeterMax) //A Medal Equivalent
								{
									accAMedalAmount += 3;
									sMedal.MouseoverAlpha = 1f;
									Vector2 offset = new Vector2(Main.rand.Next(-20, 21), Main.rand.Next(-20, 21));
									Dust dust = Dust.NewDustDirect(Main.MouseWorld + offset, 8, 8, 87, Scale: 1.25f);
									dust.noGravity = true;
									dust.velocity = -offset * 0.05f;
								}
								if (proj.type == sMedalType3 && accSMedalAmount < SMedal.ChargeMeterMax)
								{
									accSMedalAmount += 3;
									sMedal.MouseoverAlpha = 1f;
									Vector2 offset = new Vector2(Main.rand.Next(-20, 21), Main.rand.Next(-20, 21));
									Dust dust = Dust.NewDustDirect(Main.MouseWorld + offset, 8, 8, 89, Scale: 1.25f);
									dust.noGravity = true;
									dust.velocity = -offset * 0.05f;
								}
							}
						}
					}
				}
			}

			//Medal effect
			accMedalRot += 0.025f;

			if (Main.myPlayer == Player.whoAmI)
			{
				if (AccSMedal)
				{
					int sMedalType1 = ModContent.ProjectileType<SMedalPro>();
					int sMedalType2 = ModContent.ProjectileType<SMedalPro2>();
					int sMedalType3 = ModContent.ProjectileType<SMedalPro3>();

					if (Player.ownedProjectileCounts[sMedalType1] == 0)
					{
						Projectile.NewProjectile(Player.GetSource_Accessory(accSMedalItem), Player.Center, Vector2.Zero, sMedalType1, 0, 0f, Player.whoAmI, 0, 0.5f);
					}
					if (Player.ownedProjectileCounts[sMedalType2] == 0)
					{
						Projectile.NewProjectile(Player.GetSource_Accessory(accSMedalItem), Player.Center, Vector2.Zero, sMedalType2, 0, 0f, Player.whoAmI, 1, 0.5f);
					}
					if (Player.ownedProjectileCounts[sMedalType3] == 0)
					{
						Projectile.NewProjectile(Player.GetSource_Accessory(accSMedalItem), Player.Center, Vector2.Zero, sMedalType3, 0, 0f, Player.whoAmI, 2, 0.5f);
					}

					if (accSMedalAmount >= SMedal.ChargeMeterStep)
					{
						clickerBonusPercent -= 0.2f;
					}
				}
				else
				{
					accSMedalAmount = 0;

					int aMedalType = ModContent.ProjectileType<AMedalPro>();
					if (AccAMedal)
					{
						if (Player.ownedProjectileCounts[aMedalType] == 0)
						{
							Projectile.NewProjectile(Player.GetSource_Accessory(accAMedalItem), Player.Center, Vector2.Zero, aMedalType, 0, 0f, Player.whoAmI, 0, 0.5f);
						}
					}
					else
					{
						accAMedalAmount = 0;
					}

					int fMedalType = ModContent.ProjectileType<FMedalPro>();
					if (AccFMedal)
					{
						if (Player.ownedProjectileCounts[fMedalType] == 0)
						{
							Projectile.NewProjectile(Player.GetSource_Accessory(accFMedalItem), Player.Center, Vector2.Zero, fMedalType, 0, 0f, Player.whoAmI, 1, 0.5f);
						}
					}
					else
					{
						accFMedalAmount = 0;
					}
				}
			}

			HandleCPS();

			HandleRadiusAlphas();

			//Milk acc
			if (accGlassOfMilk)
			{
				float increase = Milk.DamageIncrease / 100f;
				float bonusDamage = (float)(clickerPerSecond * increase / 10f);
				if (bonusDamage >= increase)
				{
					bonusDamage = increase;
				}
				Player.GetDamage<ClickerDamage>() += bonusDamage;
			}

			//Hot Keychain
			if (accHotKeychain && !OutOfCombat)
			{
				if (clickerSelected)
				{
					if (accHotKeychainAmount < 0)
					{
						accHotKeychainAmount = 0;
					}
					accHotKeychain2 = true;

					accHotKeychainTimer++;
					if (accHotKeychainTimer > 60)
					{
						int accHotKeychainSpice = (int)(8 - clickerPerSecond);
						Color color = new Color(150, 150, 150);
						if (accHotKeychainSpice > 0)
						{
							color = new Color(255, 150, 75);

							for (int k = 0; k < 2 * accHotKeychainSpice; k++)
							{
								Vector2 offset = new Vector2(Main.rand.Next(-25, 26), Main.rand.Next(-25, 26));
								Dust dust = Dust.NewDustDirect(Player.position + offset, Player.width, Player.height, 174, Scale: 1f);
								dust.noGravity = true;
								dust.velocity = -offset * 0.05f;
							}
						}

						CombatText.NewText(Player.Hitbox, color, accHotKeychainSpice, true, true);

						accHotKeychainAmount += accHotKeychainSpice;
						accHotKeychainTimer = 0;

						if (accHotKeychainAmount > HotKeychain.ChargeMax)
						{
							Player.AddBuff(BuffID.OnFire3, 300);
							SoundEngine.PlaySound(SoundID.Item74, Player.Center);
							for (int k = 0; k < 10; k++)
							{
								Vector2 offset = new Vector2(Main.rand.Next(-25, 26), Main.rand.Next(-25, 26));
								Dust dust = Dust.NewDustDirect(Player.position + offset, Player.width, Player.height, 174, Scale: 1.5f);
								dust.noGravity = true;
								dust.velocity = -offset * 0.05f;
							}
							accHotKeychainAmount = 0;
						}
					}
				}
			}
			else
			{
				accHotKeychainTimer = 0;
				if (OutOfCombat)
				{
					accHotKeychainAmount = 0;
				}
			}

			// Out of Combat timer
			if (outOfCombatTimer > 0)
			{
				outOfCombatTimer--;
			}
		}

		public override void ModifyHitNPCWithProj(Projectile proj, NPC target, ref NPC.HitModifiers modifiers)
		{
			if (ClickerSystem.IsClickerProj(proj))
			{
				if (target.GetClickerGlobalNPC().embrittle)
				{
					modifiers.SourceDamage.Flat += Embrittle.ExtraDamage;
				}
			}

			if (ClickerSystem.IsClickerWeaponProj(proj))
			{
				int aMedalStep = AMedal.ChargeMeterStep;
				if (accAMedalAmount >= aMedalStep)
				{
					modifiers.SetCrit();
					accAMedalAmount -= aMedalStep;
				}

				int fMedalStep = FMedal.ChargeMeterStep;
				if (accFMedalAmount >= fMedalStep)
				{
					accFMedalAmount -= fMedalStep;
				}
			}
		}

		public override void OnHitNPCWithProj(Projectile proj, NPC target, NPC.HitInfo hit, int damageDone)
		{
			//Proc effects only when an actual "click" happens, and not other clicker projectiles
			if (ClickerSystem.IsClickerWeaponProj(proj))
			{
				var clickerNPC = target.GetClickerGlobalNPC();
				if (target.value > 0f)
				{
					if (AccGoldenTicket)
					{
						for (int k = 0; k < 15; k++)
						{
							int dust = Dust.NewDust(target.position, 20, 20, 11, Main.rand.NextFloat(-3f, 3f), Main.rand.NextFloat(-3f, 3f), 75, default(Color), 1.25f);
							Main.dust[dust].noGravity = true;
						}

						var entitySource = Player.GetSource_Accessory_OnHit(accGoldenTicketItem, target);
						int amount = 1 + Main.rand.Next(6);
						int coin = Item.NewItem(entitySource, target.Hitbox, ItemID.CopperCoin, amount, false, 0, false, false);
						if (amount > 0)
						{
							clickerMoneyGenerated += amount;
						}
						if (Main.netMode == NetmodeID.MultiplayerClient)
						{
							NetMessage.SendData(MessageID.SyncItem, -1, -1, null, coin, 1f);
						}
					}
				}

				if (AccPaperclips && target.CanBeChasedBy())
				{
					int matterAmount = (int)((target.height * target.width) / 200);
					if (matterAmount > 10)
					{
						matterAmount = 10;
					}
					accPaperclipsAmount += matterAmount;

					if (accPaperclipsAmount >= BottomlessBoxofPaperclips.ChargeMax)
					{
						SoundEngine.PlaySound(SoundID.Item108, Player.Center);
						for (int k = 0; k < 15; k++)
						{
							int dust = Dust.NewDust(target.position, 20, 20, 1, Main.rand.NextFloat(-5f, 5f), Main.rand.NextFloat(-5f, 5f), 150, default(Color), 1.35f);
							Main.dust[dust].noGravity = true;
						}

						if (Main.myPlayer == Player.whoAmI)
						{
							for (int k = 0; k < 4; k++)
							{
								Projectile.NewProjectile(Player.GetSource_Accessory_OnHit(accPaperclipsItem, target), clickerPosition.X, clickerPosition.Y, Main.rand.NextFloat(-1f, 1f), Main.rand.NextFloat(-6f, -2f), ModContent.ProjectileType<BottomlessBoxofPaperclipsPro>(), hit.SourceDamage, 2f, Player.whoAmI);
							}
						}

						accPaperclipsAmount = 0;
					}
				}

				if (clickerNPC.crystalSlime)
				{
					target.RequestBuffRemoval(ModContent.BuffType<Crystalized>());

					target.AddBuff(ModContent.BuffType<CrystalizedFatigue>(), 60); //Give short cooldown between application in case of proccing on the same enemy due to spread

					int crystal = ModContent.ProjectileType<ClearKeychainPro2>();
					bool spawnEffects = true;
					var entitySource = proj.GetSource_OnHit(target, context: "Acc_Crystalized");

					float total = 10f;
					int i = 0;
					while (i < total)
					{
						float hasSpawnEffects = spawnEffects ? 1f : 0f;
						Vector2 toDir = Vector2.UnitX * 0f;
						toDir += -Vector2.UnitY.RotatedBy(i * (MathHelper.TwoPi / total)) * new Vector2(10f, 10f);
						toDir = toDir.RotatedBy(target.velocity.ToRotation());
						int damageAmount = (int)(hit.SourceDamage * 0.25f);
						damageAmount = damageAmount < 1 ? 1 : damageAmount;
						Projectile.NewProjectile(entitySource, target.Center + toDir, target.velocity * 0f + toDir.SafeNormalize(Vector2.UnitY) * 10f, crystal, damageAmount, 1f, Main.myPlayer, target.whoAmI, hasSpawnEffects);
						i++;
						spawnEffects = false;
					}
				}
				
				if (clickerNPC.seafoam)
				{
					if (itemSeafoamClickerHPS < 15)
					{
						if (Player.statLife < Player.statLifeMax2)
						{
							Player.HealLife(1);
							itemSeafoamClickerHPS++;
							
							for (int i = 0; i < 5; i++)
							{
								int index = Dust.NewDust(Player.position, Player.width, Player.height, 99, 0f, 0f, 150, default(Color), 1.15f);
								Dust dust = Main.dust[index];
								dust.noGravity = true;
								dust.velocity *= 0.75f;
								int x = Main.rand.Next(-50, 51);
								int y = Main.rand.Next(-50, 51);
								dust.position.X += x;
								dust.position.Y += y;
								dust.velocity.X = -x * 0.075f;
								dust.velocity.Y = -y * 0.075f;
							}
						}
					}
					else
					{
						Player.HealLife(0);
					}
				}
			}
		}

		public override void OnHitNPC(NPC target, NPC.HitInfo hit, int damageDone)
		{
			outOfCombatTimer = OutOfCombatTimeMax;
		}

		public override void OnHurt(Player.HurtInfo info)
		{
			outOfCombatTimer = OutOfCombatTimeMax;
		}

		public override bool ConsumableDodge(Player.HurtInfo info)
		{
			if (effectTranscend)
			{
				TranscendenceDodge(true);

				Player.HealLife((int)(Player.statLifeMax2 * TranscendBuff.LifeHealedPercent / 100f));
				return true;
			}

			return base.ConsumableDodge(info);
		}

		public void TranscendenceDodge(bool broadcast = false)
		{
			SoundEngine.PlaySound(SoundID.Item176, Player.Center);

			for (int k = 0; k < 10; k++)
			{
				ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.PrincessWeapon, new ParticleOrchestraSettings
				{
					PositionInWorld = Player.Center,
					MovementVector = Main.rand.NextVector2Circular(6f, 6f)
				}, Player.whoAmI);
			}

			Player.ClearBuff(ModContent.BuffType<TranscendBuff>());

			Player.SetImmune(90, 30);

			if (Main.netMode != NetmodeID.SinglePlayer &&
				broadcast && (Player.whoAmI == Main.myPlayer || Main.netMode == NetmodeID.Server))
			{
				//If client=player needs to send, or server

				//Client sends to server, server sends to all clients but this one

				new TranscendenceDodgePacket(Player).Send(from: Player.whoAmI);
			}
		}

		public override void Kill(double damage, int hitDirection, bool pvp, PlayerDeathReason damageSource)
		{
			// Don't count as in combat after death, in case respawn timer is less than OutOfCombatTimeMax
			outOfCombatTimer = 0;
		}
		
		public override void PostUpdateMiscEffects()
		{
			SetAutoreuseWig();
		}
		
		public override void FrameEffects()
		{
			SetAutoreuseWig();
		}
		
		private void SetAutoreuseWig()
		{
			if (!Player.dead && !Player.invis && Player.head == -1 && ClickerClass.AutoreuseWig_Head_Slot != -1 &&
			!ClickerConfigClient.Instance.ToggleAutoreuseLimiter && !ClickerConfigClient.Instance.ToggleAutoreuseLimiterAccessibility)
			{
				Player.head = ClickerClass.AutoreuseWig_Head_Slot;
			}
		}

		public override void HideDrawLayers(PlayerDrawSet drawInfo)
		{
			if (DrawHotWings)
			{
				//Hide the vanilla wings layer. Important that our own replacement layer is not attached to that (via XParent), then it would get hidden aswell :failure:
				PlayerDrawLayers.Wings.Hide();
			}
		}

		public override void CatchFish(FishingAttempt attempt, ref int itemDrop, ref int npcSpawn, ref AdvancedPopupRequest sonar, ref Vector2 sonarPosition)
		{
			if (attempt.inLava && attempt.CanFishInLava)
			{
				if (Main.rand.NextBool(50)) //Roughly around [Lava] Crate chance, so around 10%
				{
					itemDrop = ModContent.ItemType<HotKeychain>();
				}
			}
		}
	}
}
